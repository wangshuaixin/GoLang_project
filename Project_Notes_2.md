### note2

+ *内置类型*是由语言提供的一组类型。比如数值类型、字符串类型 和布尔类型。
+ Go 语言里的引用类型有如下几个:切片、映射、通道、接口和函数类型
+ 当声明上述类型的变量时，创建的变量被称作标头(header)值。从技术细节上说，字符串也是一种引用类型。 每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构。
+ *结构类型*可以用来描述一组数据值，这组值的本质即可以是原始的，也可以是非原始的。如 果决定在某些东西需要删除或者添加某个结构类型的值时该结构类型的值不应该被更改，那么需 要遵守之前提到的内置类型和引用类型的规范。
+ 多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。


### 接口实现

接口是用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋给这个接口类型的值。这个赋值会把用户定义的类型的值存入接口类型的值。

所以对于接口值的调用会执行接口值里面的存储的用户定义的类型的值对应的方法。任何用户定义的类型都可以实现任何接口，所以对接口值方法的调用自然就是一种多态。在这个关系里面，用户定义的类型通常叫做*实体类型*，原因是如果离开内部存储的用户定义的类型的值的实现，接口值没有具体的行为。

### 方法集

方法集是定义接口的接受规则。

方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。

- - - 
|Values| Methods Receivers |
|-|-|
|T |(t T)|
|*T |(t T) and (t *T)|

T类型的值只包含值接受者声明的方法。而指向T类似的指针的方法集既包含值接受者声明的方法，也包含指针接受者声明的方法。从值的角度看这些规则，会显得复杂很多。

下面从接收者上看

|Methods Receivers |Values |
|-|-|
|(t T) |T and *T |
|(t *T) |*T|

这个规则说，如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值 接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。

则有时候需要传入地址（&），有时候不需要


+ 使用关键字 struct 或者通过指定已经存在的类型，可以声明用户定义的类型。
+ 方法提供了一种给用户定义的类型增加行为的方式。
+ 设计类型时需要确认类型的本质是原始的，还是非原始的。
+ 接口是声明了一组行为并支持多态的类型。
+ 嵌入类型提供了扩展类型的能力，而无需使用继承。
+ 标识符要么是从包里公开的，要么是在包里未公开的。